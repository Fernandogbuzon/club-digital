name: "1. Calendario - Actualizar fechas y horarios"

# Scraper completo: actualiza todas las competiciones, fechas, horarios.
# El frontend lee directamente de src/data/<Comp>/<Cat>/... (no usa equipos/).
# Si hay partidos pendientes de resultado, ejecuta scraper de resultados.
#
# FLUJO:
#   1. scraper_competicion.py → datos en src/data/<Comp>/<Cat>/...
#   2. Detectar pendientes de resultado
#   3. Si hay, scraper_resultados.py
#   4. Commit y push todo junto
#
# IMPORTANTE: TZ=Europe/Madrid para que datetime.now() use hora espanola

on:
  schedule:
    # 15:00 Espana = 14:00 UTC (invierno) / 13:00 UTC (verano)
    - cron: '0 13 * * *'
    - cron: '0 14 * * *'
    # 23:59 Espana = 22:59 UTC (invierno) / 21:59 UTC (verano)
    - cron: '59 21 * * *'
    - cron: '59 22 * * *'
  workflow_dispatch:

permissions:
  contents: write

concurrency:
  group: scraper-escritura
  cancel-in-progress: false

jobs:
  actualizar-calendario:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    env:
      TZ: Europe/Madrid

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: main

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'

      - name: Instalar dependencias
        run: |
          pip install playwright playwright-stealth
          playwright install chromium
          playwright install-deps chromium

      - name: Ejecutar scraper completo
        run: |
          sudo apt-get install -y xvfb > /dev/null 2>&1
          xvfb-run --auto-servernum --server-args="-screen 0 1366x768x24" \
            python scraper_competicion.py 2>&1

      - name: Detectar partidos pasados sin resultado
        id: pendientes
        run: |
          python -c "
          import json, os
          from pathlib import Path
          from datetime import datetime, timedelta

          cfg = json.loads(Path('team_config.json').read_text())
          SLUG = cfg['team_slug']
          DURATION = cfg.get('match_duration_hours', 1)
          MAX = cfg.get('max_retry_attempts', 5)
          DATA = Path('src/data')
          INTENTOS_FILE = Path('intentos_resultados.json')
          ahora = datetime.now()

          intentos = {}
          if INTENTOS_FILE.exists():
              try:
                  intentos = json.loads(INTENTOS_FILE.read_text())
                  intentos = {k:v for k,v in intentos.items()
                              if (ahora - datetime.fromisoformat(v.get('ultimo','2000-01-01'))).total_seconds() < 48*3600}
              except: pass

          pendientes = 0
          for f in DATA.rglob(f'{SLUG}*.json'):
              if 'equipos' in f.parts:
                  continue
              try:
                  data = json.loads(f.read_text())
                  if not isinstance(data, list): continue
              except: continue
              for p in data:
                  if p.get('es_resultado'): continue
                  if p.get('estado') in ('aplazado', 'esperando_resultado'): continue
                  fecha = p.get('fecha','')
                  hora = p.get('hora','')
                  pid = p.get('id','')
                  if not fecha or not pid: continue
                  try:
                      d,m,y = fecha.split('/')
                      dt = datetime(int(y),int(m),int(d))
                      if hora and ':' in hora:
                          h,mi = hora.split(':')
                          dt = dt.replace(hour=int(h),minute=int(mi))
                      else:
                          dt = dt.replace(hour=12)
                  except: continue
                  if dt + timedelta(hours=DURATION) >= ahora: continue
                  n = intentos.get(pid,{}).get('intentos',0)
                  if n >= MAX: continue
                  pendientes += 1

          print(f'Partidos pasados sin resultado: {pendientes}')
          with open(os.environ.get('GITHUB_OUTPUT','/dev/null'), 'a') as f:
              f.write(f'pendientes={\"true\" if pendientes > 0 else \"false\"}\n')
              f.write(f'num={pendientes}\n')
          "

      - name: Scraping directo de resultados pendientes (fallback)
        if: steps.pendientes.outputs.pendientes == 'true'
        id: resultados
        run: |
          echo "=== FALLBACK: Ejecutando scraper de resultados ==="
          echo "Hay ${{ steps.pendientes.outputs.num }} partido(s) pendiente(s)"

          OUTPUT=$(xvfb-run --auto-servernum --server-args="-screen 0 1366x768x24" \
            python scraper_resultados.py 2>&1) || true

          echo "$OUTPUT"

          if echo "$OUTPUT" | grep -q "RESULTADO:"; then
            echo "actualizados=true" >> $GITHUB_OUTPUT
          else
            echo "actualizados=false" >> $GITHUB_OUTPUT
          fi

      - name: Commit y push todo
        run: |
          git config --local user.name "GitHub Actions Bot"
          git config --local user.email "actions@github.com"

          # Sincronizar con remoto (puede haber cambiado durante el scraper)
          echo "Sincronizando con remoto..."
          git pull --rebase origin main || {
            echo "Rebase fallido, resolviendo..."
            git rebase --abort 2>/dev/null || true
            git pull origin main --no-rebase || true
          }

          # Anadir TODOS los archivos de datos
          git add -A src/data/ 2>/dev/null || true
          git add partidos_hoy.json comp_url_map.json intentos_resultados.json 2>/dev/null || true

          if git diff --cached --quiet; then
            echo "Sin cambios que commitear"
          else
            TIMESTAMP=$(date '+%d/%m/%Y %H:%M')

            PENDIENTES="${{ steps.pendientes.outputs.pendientes }}"
            ACTUALIZADOS="${{ steps.resultados.outputs.actualizados }}"

            if [ "$PENDIENTES" = "true" ] && [ "$ACTUALIZADOS" = "true" ]; then
              MSG="Calendario + resultados actualizados - ${TIMESTAMP}"
            elif [ "$PENDIENTES" = "true" ]; then
              MSG="Calendario actualizado + intentos resultado - ${TIMESTAMP}"
            else
              MSG="Calendario actualizado - ${TIMESTAMP}"
            fi

            git commit -m "${MSG}" -m "Actualizacion automatica"

            for intento in 1 2 3; do
              if git push origin main; then
                echo "Push exitoso (intento $intento)"
                break
              fi
              echo "Push fallido (intento $intento/3), reintentando en 5s..."
              sleep 5
              git pull --rebase origin main || {
                echo "Rebase con conflicto, haciendo abort + merge..."
                git rebase --abort 2>/dev/null || true
                git pull origin main --no-rebase || true
              }
              if [ "$intento" -eq 3 ]; then
                echo "::error::No se pudo hacer push tras 3 intentos"
                exit 1
              fi
            done
          fi

      - name: Resumen
        if: always()
        run: |
          echo "### Scraper Calendario" >> $GITHUB_STEP_SUMMARY
          echo "**Hora Espana:** $(date '+%d/%m/%Y %H:%M')" >> $GITHUB_STEP_SUMMARY
          echo "**Pendientes detectados:** ${{ steps.pendientes.outputs.num || 0 }}" >> $GITHUB_STEP_SUMMARY
          echo "**Resultados actualizados (fallback):** ${{ steps.resultados.outputs.actualizados || 'N/A' }}" >> $GITHUB_STEP_SUMMARY
