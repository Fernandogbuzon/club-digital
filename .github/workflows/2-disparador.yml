name: "2. Disparador - Detectar partidos terminados"

# Comprueba cada 10 min si hay partidos que ya terminaron
# Es ULTRA ligero: solo lee JSONs locales, no abre navegador
# Si detecta pendientes, lanza el workflow de resultados
#
# IMPORTANTE: TZ=Europe/Madrid para que datetime.now() compare
# correctamente con las horas de los partidos (hora espanola)
#
# Las horas de los partidos en los JSON estan en hora espanola.
# Sin TZ, datetime.now() en GitHub Actions devuelve UTC y causa
# un RETRASO DE 1-2 HORAS en la deteccion de partidos terminados.

on:
  schedule:
    # Sabado y Domingo: 8:00-23:50 Espana (dia completo de partidos)
    # UTC invierno: 7:00-22:50 / UTC verano: 6:00-21:50
    - cron: '*/10 6-22 * * 0,6'
    # Viernes: 16:00-00:00 Espana (tarde-noche)
    - cron: '*/10 14-23 * * 5'
    # Lunes-Jueves: 16:00-23:00 Espana (tarde-noche)
    - cron: '*/10 14-22 * * 1-4'
  workflow_dispatch:

permissions:
  contents: read
  actions: write

concurrency:
  group: scraper-disparador
  cancel-in-progress: true

jobs:
  comprobar-y-disparar:
    runs-on: ubuntu-latest
    timeout-minutes: 3
    env:
      TZ: Europe/Madrid

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Comprobar partidos pendientes
        id: check
        run: |
          python -c "
          import json, sys, os
          from pathlib import Path
          from datetime import datetime, timedelta

          # Cargar config del equipo
          cfg = json.loads(Path('team_config.json').read_text())
          SLUG = cfg['team_slug']
          DURATION = cfg.get('match_duration_hours', 1)
          MAX = cfg.get('max_retry_attempts', 5)

          DATA = Path('src/data')
          INTENTOS_FILE = Path('intentos_resultados.json')
          ahora = datetime.now()  # Con TZ=Europe/Madrid, esto es hora espanola

          print(f'Hora actual (Espana): {ahora.strftime(\"%d/%m/%Y %H:%M\")}')

          # Cargar intentos previos
          intentos = {}
          if INTENTOS_FILE.exists():
              try:
                  intentos = json.loads(INTENTOS_FILE.read_text())
                  # Limpiar viejos (>48h)
                  intentos = {k:v for k,v in intentos.items()
                              if (ahora - datetime.fromisoformat(v.get('ultimo','2000-01-01'))).total_seconds() < 48*3600}
              except: pass

          pendientes = 0
          detalles = []
          for f in DATA.rglob(f'{SLUG}*.json'):
              try:
                  data = json.loads(f.read_text())
                  if not isinstance(data, list): continue
              except: continue
              for p in data:
                  if p.get('es_resultado'): continue
                  if p.get('estado') in ('aplazado', 'esperando_resultado'): continue
                  fecha = p.get('fecha','')
                  hora = p.get('hora','')
                  pid = p.get('id','')
                  if not fecha or not pid: continue
                  try:
                      d,m,y = fecha.split('/')
                      dt = datetime(int(y),int(m),int(d))
                      if hora and ':' in hora:
                          h,mi = hora.split(':')
                          dt = dt.replace(hour=int(h),minute=int(mi))
                      else:
                          dt = dt.replace(hour=12)
                  except: continue

                  dt_fin = dt + timedelta(hours=DURATION)
                  if dt_fin >= ahora: continue

                  n = intentos.get(pid,{}).get('intentos',0)
                  if n >= MAX: continue

                  pendientes += 1
                  mins_desde_fin = int((ahora - dt_fin).total_seconds() / 60)
                  detalles.append(f'  [{n+1}/{MAX}] {p.get(\"equipo\",\"?\")} vs {p.get(\"rival\",\"?\")} ({fecha} {hora}) - hace {mins_desde_fin}min')

          print(f'Pendientes: {pendientes}')
          for d in detalles:
              print(d)

          if pendientes > 0:
              print('HAY_PENDIENTES=true')
          else:
              print('HAY_PENDIENTES=false')

          # Output para GitHub
          with open(os.environ.get('GITHUB_OUTPUT','/dev/null'), 'a') as f:
              f.write(f'pendientes={\"true\" if pendientes > 0 else \"false\"}\n')
              f.write(f'num={pendientes}\n')
          "

      - name: Disparar scraper de resultados
        if: steps.check.outputs.pendientes == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: '3-resultados.yml',
                ref: 'main',
              });
              console.log(`Disparado scraper de resultados (${${{ steps.check.outputs.num }}} pendientes)`);
            } catch (error) {
              console.error(`Error al disparar workflow: ${error.message}`);
              core.setFailed(`No se pudo disparar el workflow de resultados: ${error.message}`);
            }

      - name: Resumen
        if: always()
        run: |
          echo "### Disparador" >> $GITHUB_STEP_SUMMARY
          echo "**Hora Espana:** $(date '+%H:%M')" >> $GITHUB_STEP_SUMMARY
          echo "**Pendientes:** ${{ steps.check.outputs.num || 0 }}" >> $GITHUB_STEP_SUMMARY
          echo "**Disparado:** ${{ steps.check.outputs.pendientes || 'false' }}" >> $GITHUB_STEP_SUMMARY
